
import { NextResponse, type NextRequest } from 'next/server';
import type { AgentRegistration, ANSNameParts, ANSProtocol, SignedCertificate } from '@/lib/types';
import { z } from 'zod';
import crypto from 'crypto';
import { getCACryptoKeys } from '@/app/api/secure-binding/ca/route'; // Adjust path as necessary, ensure it's exportable

// In-memory store for agent registrations
let agentRegistry: AgentRegistration[] = [];

// Schema for validating the registration request body
// certificatePem is removed as it will be generated by this API.
const registrationRequestSchema = z.object({
  protocol: z.enum(["a2a", "mcp", "acp", "other"]),
  agentID: z.string().min(1, "AgentID is required"),
  agentCapability: z.string().min(1, "AgentCapability is required"),
  provider: z.string().min(1, "Provider is required"),
  version: z.string().regex(/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/, "Version must be a valid Semantic Version"),
  extension: z.string().optional(),
  protocolExtensions: z.record(z.any()).refine(data => {
    if (!data.endpoint || typeof data.endpoint !== 'string') {
        return false;
    }
    return true;
  }, {message: "Protocol extensions must contain an 'endpoint' string."}),
});

function constructANSName(parts: ANSNameParts): string {
  let name = `${parts.protocol}://${parts.agentID}.${parts.agentCapability}.${parts.provider}.v${parts.version}`;
  if (parts.extension && parts.extension.trim() !== "") {
    name += `.${parts.extension.trim()}`;
  }
  return name;
}

export async function GET() {
  // Ensure CA keys are available/generated if other parts of the system rely on them being initialized via GET
  // This is a simplified way to ensure CA setup for the demo.
  if (!getCACryptoKeys()) {
    await fetch(new URL('/api/secure-binding/ca', 'http://localhost:9002'), { method: 'POST' }); // Use full URL for server-side fetch
  }
  return NextResponse.json(agentRegistry);
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const parsedBody = registrationRequestSchema.safeParse(body);

    if (!parsedBody.success) {
      return NextResponse.json({ error: "Invalid registration data", details: parsedBody.error.format() }, { status: 400 });
    }

    const { protocol, agentID, agentCapability, provider, version, extension, protocolExtensions } = parsedBody.data;

    const ansNameParts: ANSNameParts = { protocol: protocol as ANSProtocol, agentID, agentCapability, provider, version, extension };
    const ansName = constructANSName(ansNameParts);

    // Check for duplicate ANSName
    if (agentRegistry.some(agent => agent.ansName === ansName)) {
      return NextResponse.json({ error: `Agent with ANSName '${ansName}' already registered.` }, { status: 409 });
    }

    // 1. Generate Key Pair for the Agent
    const { publicKey: agentPublicKeyPem, privateKey: agentPrivateKeyPem } = crypto.generateKeyPairSync('ec', {
      namedCurve: 'P-256',
      publicKeyEncoding: { type: 'spki', format: 'pem' },
      privateKeyEncoding: { type: 'pkcs8', format: 'pem' },
    });
    // Note: agentPrivateKeyPem would typically be returned to the agent securely or managed by a vault.
    // For this registry, we only need the public key for the certificate. We will discard the private key here.

    // 2. Issue Certificate using CA
    const caCryptoKeys = getCACryptoKeys();
    if (!caCryptoKeys) {
      // Attempt to initialize CA if not already done. This is a simplified approach for the demo.
      // In a real system, CA management would be more robust.
      await fetch(new URL('/api/secure-binding/ca', request.url).toString(), { method: 'POST' });
      const updatedCaKeys = getCACryptoKeys();
      if (!updatedCaKeys) {
        return NextResponse.json({ error: 'CA not initialized and auto-initialization failed. Please setup CA first.' }, { status: 500 });
      }
       // Re-assign caCryptoKeys after ensuring initialization
       Object.assign(caCryptoKeys || {}, updatedCaKeys); // This line is problematic, re-fetch or handle better
       const freshCaKeys = getCACryptoKeys(); // Fetch again
       if(!freshCaKeys) {
         return NextResponse.json({ error: 'CA could not be initialized.' }, { status: 500 });
       }
       // Use freshCaKeys instead of caCryptoKeys for signing
       const certPayloadForSign: Omit<SignedCertificate, 'signature'> = {
        subjectAgentId: agentID,
        subjectPublicKey: agentPublicKeyPem,
        subjectAnsEndpoint: ansName,
        issuer: "DemoCA",
        validFrom: new Date().toISOString(),
        validTo: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year validity
      };
      const sign = crypto.createSign('SHA256');
      sign.update(JSON.stringify(certPayloadForSign));
      sign.end();
      const signature = sign.sign(freshCaKeys.privateKey, 'base64');
      const agentCertificate: SignedCertificate = { ...certPayloadForSign, signature };
      
      const newAgent: AgentRegistration = {
        id: `reg-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
        ...ansNameParts,
        ansName,
        agentCertificate, // Store the issued certificate
        protocolExtensions,
        timestamp: new Date().toISOString(),
      };
      agentRegistry.push(newAgent);
      console.log(`Agent registered: ${ansName} with issued certificate.`);
      return NextResponse.json(newAgent, { status: 201 });

    } else {
        // CA keys were available from the start
        const certPayloadForSign: Omit<SignedCertificate, 'signature'> = {
            subjectAgentId: agentID,
            subjectPublicKey: agentPublicKeyPem,
            subjectAnsEndpoint: ansName,
            issuer: "DemoCA",
            validFrom: new Date().toISOString(),
            validTo: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year validity
        };
        const sign = crypto.createSign('SHA256');
        sign.update(JSON.stringify(certPayloadForSign));
        sign.end();
        const signature = sign.sign(caCryptoKeys.privateKey, 'base64');
        const agentCertificate: SignedCertificate = { ...certPayloadForSign, signature };

        const newAgent: AgentRegistration = {
            id: `reg-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
            ...ansNameParts,
            ansName,
            agentCertificate, // Store the issued certificate
            protocolExtensions,
            timestamp: new Date().toISOString(),
        };

        agentRegistry.push(newAgent);
        console.log(`Agent registered: ${ansName} with issued certificate.`);
        return NextResponse.json(newAgent, { status: 201 });
    }


  } catch (error) {
    console.error("Agent registration error:", error);
    let message = "Failed to register agent.";
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
